package com.digitalstudio.app.service;

import com.digitalstudio.app.model.ServiceOrder;
import com.digitalstudio.app.model.Customer;
import com.digitalstudio.app.repository.ServiceOrderRepository;
import com.digitalstudio.app.repository.CustomerRepository;
import com.digitalstudio.app.repository.UploadRepository;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import jakarta.persistence.criteria.Predicate;

import java.time.LocalDate;
import java.util.*;
import java.util.UUID;

@Service
public class ServiceOrderService {

    @Autowired
    private ServiceOrderRepository serviceOrderRepository;

    @Autowired
    private UploadRepository uploadRepository;

    @Autowired
    private CustomerRepository customerRepository;

    @Autowired
    private CustomerService customerService;

    @Autowired
    private ObjectMapper objectMapper;

    public Page<ServiceOrder> getAllOrders(LocalDate startDate, LocalDate endDate,
            String search, List<String> services, int page, int size) {
        Specification<ServiceOrder> spec = (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (startDate != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("createdAt"), startDate.atStartOfDay()));
            }
            if (endDate != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("createdAt"), endDate.atTime(23, 59, 59)));
            }

            if (services != null && !services.isEmpty()) {
                predicates.add(root.get("serviceName").in(services));
            }

            if (search != null && !search.isEmpty()) {
                String likePattern = "%" + search.toLowerCase() + "%";
                Predicate customerName = cb.like(cb.lower(root.get("customer").get("name")), likePattern);
                Predicate serviceName = cb.like(cb.lower(root.get("serviceName")), likePattern);
                Predicate description = cb.like(cb.lower(root.get("description")), likePattern);
                Predicate status = cb.like(cb.lower(root.get("status")), likePattern);
                predicates.add(cb.or(customerName, serviceName, description, status));
            }

            return cb.and(predicates.toArray(new Predicate[0]));
        };

        Page<ServiceOrder> pageData = serviceOrderRepository.findAll(spec,
                PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "createdAt")));

        for (ServiceOrder so : pageData.getContent()) {
            if (so.getUploadIdsJson() != null && !so.getUploadIdsJson().isEmpty()) {
                try {
                    List<String> ids = objectMapper.readValue(so.getUploadIdsJson(),
                            new com.fasterxml.jackson.core.type.TypeReference<List<String>>() {
                            });

                    Map<String, Boolean> availabilityMap = new HashMap<>();
                    for (String id : ids) {
                        String rawId = id;
                        if (rawId.contains(".")) {
                            rawId = rawId.substring(0, rawId.lastIndexOf('.'));
                        }
                        Optional<com.digitalstudio.app.model.Upload> upload = uploadRepository.findById(rawId);
                        availabilityMap.put(id, upload.isPresent() && upload.get().getIsAvailable());
                    }
                    so.setIsFileAvailable(availabilityMap);
                } catch (Exception e) {
                    System.err.println("Error parsing upload IDs: " + e.getMessage());
                }
            }
        }

        return pageData;
    }

    public ServiceOrder createOrder(ServiceOrder order) {
        // IDs are now auto-generated by JPA UUID strategy.

        if (order.getCustomer() != null) {
            Customer payloadCustomer = order.getCustomer();
            Customer finalCustomer = null;

            // 1. Try to find by ID if provided
            if (payloadCustomer.getId() != null) {
                finalCustomer = customerRepository.findById(payloadCustomer.getId()).orElse(null);
            }

            // 2. If not found by ID, try mobile
            if (finalCustomer == null && payloadCustomer.getMobile() != null
                    && !payloadCustomer.getMobile().trim().isEmpty()) {
                // Use stream or list handling if duplicates exist to avoid crashes
                // Since this caused a crash, let's just take the first one if multiple exist
                // (unlikely for valid numbers, but safe)
                // For now, sticking to finding specific unique ones, assuming real mobiles are
                // unique.
                // If the issue was purely empty strings, the condition above fixes it.
                // If real numbers are duplicated, we should fix the repository or data.
                // Let's rely on the empty check for now.
                finalCustomer = customerRepository.findByMobile(payloadCustomer.getMobile()).orElse(null);
            }

            // 3. If still null, create new
            if (finalCustomer == null) {
                Customer newCust = new Customer();
                newCust.setMobile(payloadCustomer.getMobile());
                newCust.setName(payloadCustomer.getName());
                // Generate ID if missing
                if (payloadCustomer.getId() == null) {
                    newCust.setId(customerService.generateNewCustomerId());
                } else {
                    newCust.setId(payloadCustomer.getId());
                }
                finalCustomer = customerRepository.save(newCust);
            } else {
                // Optional: Update name if provided and different?
                // For now, just ensure we use the managed entity.
                if (payloadCustomer.getName() != null && !payloadCustomer.getName().isEmpty()) {
                    finalCustomer.setName(payloadCustomer.getName()); // Update name if needed
                    finalCustomer = customerRepository.save(finalCustomer);
                }
            }
            order.setCustomer(finalCustomer);
        }

        return serviceOrderRepository.save(order);
    }

    public ServiceOrder getOrderById(UUID id) {
        return serviceOrderRepository.findById(id).orElse(null);
    }

    public ServiceOrder updateStatus(UUID orderId, String newStatus) {
        ServiceOrder order = serviceOrderRepository.findById(orderId)
                .orElseThrow(() -> new RuntimeException("Order not found"));

        order.setStatus(newStatus);
        return serviceOrderRepository.save(order);
    }

    public ServiceOrder updateOrder(UUID id, Map<String, Object> updates) {
        ServiceOrder order = serviceOrderRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Order not found"));

        if (updates.containsKey("status"))
            order.setStatus((String) updates.get("status"));
        if (updates.containsKey("serviceName"))
            order.setServiceName((String) updates.get("serviceName"));
        if (updates.containsKey("description"))
            order.setDescription((String) updates.get("description"));
        if (updates.containsKey("amount"))
            order.setAmount(((Number) updates.get("amount")).doubleValue());

        // Handle Payment Details updates
        if (updates.containsKey("payment")) {
            Object paymentObj = updates.get("payment");
            if (paymentObj instanceof Map) {
                Map<String, Object> payMap = (Map<String, Object>) paymentObj;
                com.digitalstudio.app.model.Payment payment = order.getPayment();
                if (payment == null)
                    payment = new com.digitalstudio.app.model.Payment();

                if (payMap.containsKey("paymentMode"))
                    payment.setPaymentMode((String) payMap.get("paymentMode"));
                if (payMap.containsKey("totalAmount"))
                    payment.setTotalAmount(((Number) payMap.get("totalAmount")).doubleValue());
                if (payMap.containsKey("advanceAmount"))
                    payment.setAdvanceAmount(((Number) payMap.get("advanceAmount")).doubleValue());
                // amountPaid is typically tracked via advanceAmount in this simple model or
                // calculated
                if (payMap.containsKey("discountAmount"))
                    payment.setDiscountAmount(((Number) payMap.get("discountAmount")).doubleValue());
                if (payMap.containsKey("dueAmount"))
                    payment.setDueAmount(((Number) payMap.get("dueAmount")).doubleValue());

                order.setPayment(payment);
            }
        }

        // Handle Customer Updates
        if (updates.containsKey("customer")) {
            Object custObj = updates.get("customer");
            if (custObj instanceof Map) {
                Map<String, Object> custMap = (Map<String, Object>) custObj;
                Customer cust = order.getCustomer();
                if (cust != null && custMap.containsKey("name")) {
                    String newName = (String) custMap.get("name");
                    if (newName != null && !newName.isEmpty() && !newName.equals(cust.getName())) {
                        cust.setName(newName);
                        customerRepository.save(cust);
                    }
                }
            }
        }

        return serviceOrderRepository.save(order);
    }
}
