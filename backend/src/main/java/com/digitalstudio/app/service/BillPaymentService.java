package com.digitalstudio.app.service;

import com.digitalstudio.app.model.BillPaymentTransaction;
import com.digitalstudio.app.model.Customer;
import com.digitalstudio.app.repository.BillPaymentRepository;
import com.digitalstudio.app.repository.CustomerRepository;
import com.digitalstudio.app.repository.UploadRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import java.util.UUID;

@Service
public class BillPaymentService {

    @Autowired
    private BillPaymentRepository billPaymentRepository;

    @Autowired
    private UploadRepository uploadRepository;

    @Autowired
    private CustomerRepository customerRepository;

    @Autowired
    private CustomerService customerService;

    public Page<BillPaymentTransaction> getAllTransactions(java.time.LocalDate startDate, java.time.LocalDate endDate,
            String search, java.util.List<String> transactionTypes, int page, int size) {
        org.springframework.data.jpa.domain.Specification<BillPaymentTransaction> spec = (root, query, cb) -> {
            java.util.List<jakarta.persistence.criteria.Predicate> predicates = new java.util.ArrayList<>();

            if (startDate != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get("createdAt"), startDate.atStartOfDay()));
            }
            if (endDate != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get("createdAt"), endDate.atTime(23, 59, 59)));
            }

            if (transactionTypes != null && !transactionTypes.isEmpty()) {
                java.util.List<String> validTypes = transactionTypes.stream()
                        .map(String::toUpperCase)
                        .collect(java.util.stream.Collectors.toList());
                predicates.add(root.get("transactionType").as(String.class).in(validTypes));
            }

            if (search != null && !search.isEmpty()) {
                String likePattern = "%" + search.toLowerCase() + "%";
                jakarta.persistence.criteria.Predicate customerName = cb
                        .like(cb.lower(root.get("customer").get("name")), likePattern);
                jakarta.persistence.criteria.Predicate customerMobile = cb.like(root.get("customer").get("mobile"),
                        likePattern);
                jakarta.persistence.criteria.Predicate operator = cb.like(cb.lower(root.get("operator")), likePattern);
                jakarta.persistence.criteria.Predicate billId = cb.like(cb.lower(root.get("billId")), likePattern);
                jakarta.persistence.criteria.Predicate billName = cb.like(cb.lower(root.get("billCustomerName")),
                        likePattern);
                jakarta.persistence.criteria.Predicate status = cb.like(cb.lower(root.get("status")), likePattern);

                predicates.add(cb.or(customerName, customerMobile, operator, billId, billName, status));
            }

            return cb.and(predicates.toArray(new jakarta.persistence.criteria.Predicate[0]));
        };

        Page<BillPaymentTransaction> pageData = billPaymentRepository.findAll(spec,
                PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "createdAt")));

        // Populate Availability
        for (BillPaymentTransaction txn : pageData.getContent()) {
            if (txn.getUploadId() != null) {
                String rawId = txn.getUploadId();
                if (rawId.contains(".")) {
                    rawId = rawId.substring(0, rawId.lastIndexOf('.'));
                }
                uploadRepository.findById(rawId).ifPresent(upload -> {
                    txn.setIsFileAvailable(upload.getIsAvailable());
                });
            }
        }

        return pageData;
    }

    public BillPaymentTransaction createTransaction(BillPaymentTransaction transaction) {
        // IDs are now auto-generated by JPA UUID strategy.

        if (transaction.getCustomer() != null) {
            Customer payloadCustomer = transaction.getCustomer();
            if (payloadCustomer.getId() == null) {
                // Determine if this is a new customer or existing by mobile
                if (payloadCustomer.getMobile() != null && !payloadCustomer.getMobile().isEmpty()) {
                    Customer existing = customerRepository.findByMobile(payloadCustomer.getMobile()).orElse(null);
                    if (existing != null) {
                        transaction.setCustomer(existing);
                    } else {
                        // Create shell if needed (logic from ServiceOrder)
                        Customer newCust = new Customer();
                        newCust.setMobile(payloadCustomer.getMobile());
                        newCust.setName(payloadCustomer.getName());
                        newCust.setId(customerService.generateNewCustomerId());
                        transaction.setCustomer(customerRepository.save(newCust));
                    }
                }
            }
        }

        return billPaymentRepository.save(transaction);
    }

    public BillPaymentTransaction getById(UUID id) {
        return billPaymentRepository.findById(id).orElse(null);
    }

    public BillPaymentTransaction updateStatus(UUID id, String status) {
        BillPaymentTransaction transaction = billPaymentRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Transaction not found"));
        transaction.setStatus(status);
        return billPaymentRepository.save(transaction);
    }

    public BillPaymentTransaction updateTransaction(UUID id, java.util.Map<String, Object> updates) {
        BillPaymentTransaction transaction = billPaymentRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Transaction not found"));

        if (updates.containsKey("status")) {
            transaction.setStatus((String) updates.get("status"));
        }
        if (updates.containsKey("operator")) {
            transaction.setOperator((String) updates.get("operator"));
        }
        if (updates.containsKey("billId")) {
            transaction.setBillId((String) updates.get("billId"));
        }
        if (updates.containsKey("billCustomerName")) {
            transaction.setBillCustomerName((String) updates.get("billCustomerName"));
        }
        if (updates.containsKey("transactionType")) {
            try {
                // Ensure type safety or ignore if not changeable
                // transaction.setTransactionType(BillPaymentTransaction.TransactionType.valueOf((String)
                // updates.get("transactionType")));
            } catch (Exception e) {
            }
        }

        // Handle Payment Details updates
        if (updates.containsKey("payment")) {
            Object paymentObj = updates.get("payment");
            if (paymentObj instanceof java.util.Map) {
                java.util.Map<String, Object> payMap = (java.util.Map<String, Object>) paymentObj;
                com.digitalstudio.app.model.Payment payment = transaction.getPayment();
                if (payment == null)
                    payment = new com.digitalstudio.app.model.Payment();

                if (payMap.containsKey("paymentMode"))
                    payment.setPaymentMode((String) payMap.get("paymentMode"));
                if (payMap.containsKey("totalAmount"))
                    payment.setTotalAmount(((Number) payMap.get("totalAmount")).doubleValue());
                if (payMap.containsKey("advanceAmount"))
                    payment.setAdvanceAmount(((Number) payMap.get("advanceAmount")).doubleValue());
                // amountPaid mapped to advanceAmount by convention if needed, removing invalid
                // setter
                if (payMap.containsKey("discountAmount"))
                    payment.setDiscountAmount(((Number) payMap.get("discountAmount")).doubleValue());
                if (payMap.containsKey("dueAmount"))
                    payment.setDueAmount(((Number) payMap.get("dueAmount")).doubleValue());

                transaction.setPayment(payment);
            }
        }

        // Handle Customer Updates (Name only usually)
        if (updates.containsKey("customer")) {
            Object custObj = updates.get("customer");
            if (custObj instanceof java.util.Map) {
                java.util.Map<String, Object> custMap = (java.util.Map<String, Object>) custObj;
                Customer cust = transaction.getCustomer();
                if (cust != null && custMap.containsKey("name")) {
                    String newName = (String) custMap.get("name");
                    if (newName != null && !newName.isEmpty() && !newName.equals(cust.getName())) {
                        cust.setName(newName);
                        customerRepository.save(cust);
                    }
                }
                // If ID changes, we might need repository lookup, but usually we just edit name
            }
        }

        return billPaymentRepository.save(transaction);
    }

    public java.util.List<java.util.Map<String, String>> getSuggestions(String mobile) {
        return billPaymentRepository.findSuggestions(mobile);
    }
}
